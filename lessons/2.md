# Aula 2 - Testando a aplica√ß√£o como um usu√°rio real

Antes de come√ßar, d√™ uma navegada pela os arquivos contidos no diret√≥rio `cypress/` para se familiarizar com o c√≥digo existente.

Agora que voc√™ j√° conhece um pouco a base de c√≥digo, podemos come√ßar a melhor√°-lo!

J√° no come√ßo da suite de testes existente, temos um espa√ßo para melhoria.

Me refiro ao seguinte trecho de c√≥digo.

```js
beforeEach(() => {
  cy.visit('/')

  cy.assertLoadingIsShownAndHidden()
  cy.contains('More').should('be.visible')
})
```

Este c√≥digo funciona, por√©m n√£o √© assim que um usu√°rio real se comporta quando utilizando uma aplica√ß√£o web que faz buscas. Ou seja, o usu√°rio n√£o espera primeiro pelo componente que exibe o texto `Loading ...` estar vis√≠vel, depois n√£o estar mais vis√≠vel, e ent√£o pelo bot√£o de pagina√ß√£o estar vis√≠vel.

Se nos colocarmos no lugar do usu√°rio, ap√≥s visitarmos a aplica√ß√£o, simplesmente esperamos que a mesma esteja em um estado pronta para receber uma nova busca. Nada mais.

Pensando nisso, seria legal se pud√©ssemos interceptar a requisi√ß√£o que a aplica√ß√£o faz √† API do **Hackernews**, darmos um alias √† ela e ent√£o aguardarmos por tal requisi√ß√£o acabar antes de seguir adiante.

Sorte nossa que estamos usando o [**Cypress**](https://cypress.io) para escrevermos os testes. üöÄ

O **Cypress** possui uma funcionalidade chamada `cy.intercept()`, a qual pode nos ajudar bastante.

A prop√≥sito, escrevi um post sobre [**como aguardar uma requisi√ß√£o acabar antes de seguir adiante com Cypress**](https://talkingabouttesting.com/2021/02/12/como-aguardar-um-requisicao-acabar-antes-de-seguir-adiante-com-cypress/). Recomendo a leitura antes de seguir adiante. √â melhor fixar o conhecimento do que correr e n√£o entender o que est√° fazendo, n√£o √© mesmo?

Para mais detalhes sobre a funcionalidade `cy.intercept()`, recomendo a leitura da [**documenta√ß√£o oficial do Cypress**](https://docs.cypress.io/api/commands/intercept.html).

## Exerc√≠cio

Refatore o bloco de c√≥digo do primeiro `beforeEach` da suite de testes, para em vez de aguardar por elementos estarem vis√≠veis ou n√£o, aguardar por uma requisi√ß√£o do tipo `GET` para o endere√ßo `**/search?query=React&page=0` antes de seguir adiente.

> üßôüèª Ao final de cada implementa√ß√£o, recomendo executar o comando `npm run lint`, o qual ir√° fazer a an√°lise est√°tica do c√≥digo para garantir que o estilo de codifica√ß√£o definido est√° sendo seguido.

> üßôüèø Alguns problemas encontrados via an√°lise est√°tica de c√≥digo podem ser automaticamente resolvidos executando o comando `npm run lint:fix`.

> üßôüèº Ap√≥s a resolu√ß√£o de cada exerc√≠cio, lembre-se de executar os testes com o comando `npm test`, ou utilizando o test _Runner_ do Cypress (com o comando `npm run cy:open`) e garanta que todos os testes continuam passando antes de seguir adiante.

## Extra credit 1

> Extra credits s√£o exerc√≠cios extra para te ensinar outras formas de resolver o mesmo problema, assim voc√™ aumenta suas possibilidades.

Refatore mais uma vez o bloco de c√≥digo do `beforeEach`, para que este aguarde por uma requisi√ß√£o do tipo `GET` para o pathname `**/search`, passando o valores das _query strings_ `query` e `page` como propriedades do objeto `query` que pode ser passado ao `cy.intercept()`.

üôä üòÉ

```js
cy.intercept({
  method: 'GET',
  pathname: '**/search',
  query: {
    query: 'React',
    page: '0'
  }
}).as('getStories')
```

## Extra credit 2

Nos seguintes testes, requisi√ß√µes do tipo `GET` tamb√©m s√£o feitas √† API do **Hackernews**, e portanto, poder√≠amos aguardar por tais requisi√ß√µes acabarem antes de seguir adiente, em vez de aguardar por elementos estarem ou n√£o vis√≠veis.

* `shows 20 stories, then the next 20 after clicking "More"`
* `types and hits ENTER`
* `types and clicks the submit button`
* `searches via the last searched term`
* `shows a max of 5 buttons for the last searched terms`

Tua miss√£o √© refatorar os testes acima utilizando uma das abordagens das refatora√ß√µes anteriores, para testarmos a aplica√ß√£o o mais pr√≥ximo de como usu√°rios reais √† utilizam.

> Gravei um v√≠deo com a solu√ß√£o para cada um dos testes acima, ou seja `extra-credit-2-1`, `extra-credit-2-2`, etc.

**Curiosidade**: _Voc√™ percebeu a implementa√ß√£o do teste `shows a max of 5 buttons for the last searched terms`, onde em vez de repetir o c√≥digo para fazer 6 buscas, utilizo a funcionalidade `Cypress._.times()`, passando como primeiro argumento o n√∫mero `6`, e como segundo argumento uma fun√ß√£o que executa a busca? Isso se chama "**simplificando comandos repetitivos**"_.

## Extra credit 3

Logo ap√≥s o teste `types and clicks the submit button`, adicione um novo teste chamado `types and submits the form directly`.

Algo como o seguinte.

```js
it('types and submits the form directly', () => {
  cy.get('form input[type="text"]')
    .should('be.visible')
    .clear()
    .type('cypress')
  cy.get('form').submit()

  // Assertion here
})
```

Resolvi trazer este _extra credit_ para demonstrar uma op√ß√£o dispon√≠vel para submiss√£o de formul√°rios com **Cypress**, por√©m, a qual n√£o recomendo utilizar a n√£o ser que seja totalmente necess√°rio, visto que n√£o √© assim que usu√°rios utilizam a aplica√ß√£o. Ou seja, os usu√°rios n√£o tem como invocar a submiss√£o do formul√°rio diretamente.

**Obs.:** üßôüèø Visto que estamos testando a aplica√ß√£o sob a perspectiva de um usu√°rio real, delete este novo teste ap√≥s sua implementa√ß√£o. S√≥ queria mostrar pra voc√™ esta possibilidade.

___

Est√° ficando melhor, hein?

V√° para a [aula 3](./3.md) para implementarmos alguns testes pendentes, para situa√ß√µes de erro.
